
Below is a minimal, copy-pasteable how-to for **both C and C++** (no TypeScript, no bundler, just ES modules + static hosting). I‚Äôll also note a few modern knobs (ESM output, memory growth, threading)

---

# 1) Install toolchain

```bash
# one-time: install and activate the Emscripten SDK
git clone https://github.com/emscripten-core/emsdk
cd emsdk
./emsdk install latest    wasmmhmm
./emsdk activate latest
source ./emsdk_env.sh   # add to your shell rc to auto-enable
```

Emscripten emits a **.wasm** plus a small JS loader; you can also ask for ES-module output. ([Emscripten][1])

---

# 2) Project layout

```
wasm-c-demo/
‚îú‚îÄ src/
‚îÇ  ‚îú‚îÄ c_demo.c
‚îÇ  ‚îî‚îÄ cpp_demo.cpp
‚îú‚îÄ pkg/              # build output goes here
‚îî‚îÄ web/
   ‚îú‚îÄ index.html
   ‚îî‚îÄ main.js
```

---

# 3) C example (no frameworks)

## `src/c_demo.c`

```c
#include <emscripten/emscripten.h>
#include <stdbool.h>
#include <stdint.h>

EMSCRIPTEN_KEEPALIVE
const char* greet(const char* name) {
  // NOTE: returns static storage for simplicity; for real apps, pass a JS buffer in.
  static char buf[128];
  snprintf(buf, sizeof(buf), "hello, %s üëã (from C/WASM)", name ? name : "world");
  return buf;
}

EMSCRIPTEN_KEEPALIVE
uint32_t count_primes(uint32_t n) {
  if (n < 2) return 0;
  uint32_t size = n + 1, count = 0;
  bool *is_prime = (bool*)malloc(size);
  memset(is_prime, true, size);
  is_prime[0]=false; is_prime[1]=false;
  for (uint32_t p=2; p*p<=n; ++p)
    if (is_prime[p])
      for (uint32_t m=p*p; m<=n; m+=p) is_prime[m]=false;
  for (uint32_t i=2;i<=n;++i) if (is_prime[i]) ++count;
  free(is_prime);
  return count;
}
```

> `EMSCRIPTEN_KEEPALIVE` marks functions as exported without extra flags; alternatively you can export by name via `-s EXPORTED_FUNCTIONS=['_greet','_count_primes']`. ([Emscripten][2])

### Build (C ‚Üí WASM, ES modules, no TS)

```bash
emcc src/c_demo.c -O3 \
  -sENVIRONMENT=web \
  -sEXPORT_ES6=1 -sMODULARIZE=1 \
  -sALLOW_MEMORY_GROWTH=1 \
  -sEXPORTED_RUNTIME_METHODS=['ccall','cwrap'] \
  -o pkg/c_demo.js
```

This produces `pkg/c_demo.js` (ESM factory) and `pkg/c_demo.wasm`. You‚Äôll **import the JS**; it loads the `.wasm`. `MODULARIZE+EXPORT_ES6` lets you `import createModule from "./c_demo.js"` and then `await createModule()` to get an instance. Using `ccall/cwrap` is the simplest way to call plain C exports. ([Emscripten][3])

---

# 4) C++ example (with Embind)

For C++ you can bind functions/classes cleanly with **Embind**:

## `src/cpp_demo.cpp`

```cpp
#include <string>
#include <emscripten/bind.h>

std::string greet_cpp(std::string name) {
  return "hello, " + (name.empty() ? std::string("world") : name) + " üëã (from C++/WASM)";
}

uint32_t count_primes_cpp(uint32_t n) {
  if (n < 2) return 0;
  std::vector<bool> is_prime(n+1, true);
  is_prime[0]=false; is_prime[1]=false;
  for (uint32_t p=2; p*p<=n; ++p)
    if (is_prime[p])
      for (uint32_t m=p*p; m<=n; m+=p) is_prime[m]=false;
  return std::count(is_prime.begin(), is_prime.end(), true);
}

EMSCRIPTEN_BINDINGS(my_module) {
  emscripten::function("greet_cpp", &greet_cpp);
  emscripten::function("count_primes_cpp", &count_primes_cpp);
}
```

### Build (C++ ‚Üí WASM, Embind)

```bash
em++ src/cpp_demo.cpp -O3 \
  -sENVIRONMENT=web \
  -sEXPORT_ES6=1 -sMODULARIZE=1 \
  -sALLOW_MEMORY_GROWTH=1 \
  --bind \
  -o pkg/cpp_demo.js
```

Embind exposes idiomatic JS methods on the instantiated module (e.g. `module.greet_cpp("you")`). ([Emscripten][4])

---

# 5) Frontend (no bundler)

## `web/index.html`

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>C/C++ ‚Üí WebAssembly Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>body{font-family:system-ui,sans-serif;margin:2rem}</style>
</head>
<body>
  <h1>C/C++ ‚Üí WASM (no frameworks)</h1>

  <div>
    <input id="name" placeholder="Your name" />
    <button id="hello">Greet (C)</button>
    <button id="hello_cpp">Greet (C++)</button>
    <div id="greeting"></div>
  </div>

  <div>
    <input id="limit" type="number" value="100000" />
    <button id="count">Count primes ‚â§ n (C)</button>
    <button id="count_cpp">Count primes ‚â§ n (C++)</button>
    <div>Result: <span id="result">‚Äî</span></div>
  </div>

  <script type="module" src="./main.js"></script>
</body>
</html>
```

## `web/main.js`

```js
// Import ES-module factories generated by emscripten:
import createC from "../pkg/c_demo.js";
import createCpp from "../pkg/cpp_demo.js";

const C = await createC();     // loads c_demo.wasm
const CPP = await createCpp(); // loads cpp_demo.wasm

// Plain C exports via cwrap (use 'string'/'number' for types)
const greet = C.cwrap("greet", "string", ["string"]);
const count_primes = C.cwrap("count_primes", "number", ["number"]);

// C++ Embind exports are methods on the module:
const greet_cpp = CPP.greet_cpp;
const count_primes_cpp = CPP.count_primes_cpp;

document.getElementById("hello").onclick = () => {
  const name = document.getElementById("name").value || "world";
  document.getElementById("greeting").textContent = greet(name);
};
document.getElementById("hello_cpp").onclick = () => {
  const name = document.getElementById("name").value || "world";
  document.getElementById("greeting").textContent = greet_cpp(name);
};

document.getElementById("count").onclick = () => {
  const n = +document.getElementById("limit").value || 0;
  const t0 = performance.now();
  const c = count_primes(n);
  const t1 = performance.now();
  document.getElementById("result").textContent =
    `${c} primes (C) in ${(t1 - t0).toFixed(1)} ms`;
};
document.getElementById("count_cpp").onclick = () => {
  const n = +document.getElementById("limit").value || 0;
  const t0 = performance.now();
  const c = count_primes_cpp(n);
  const t1 = performance.now();
  document.getElementById("result").textContent =
    `${c} primes (C++) in ${(t1 - t0).toFixed(1)} ms`;
};
```

Notes:

* `-sEXPORT_ES6=1 -sMODULARIZE=1` yields an **ES-module factory** you can `import` and `await`. ([Emscripten][3])
* `cwrap/ccall` are built-ins for calling C exports from JS. ([Emscripten][5])

---

# 6) Build variants & useful flags

* **Min size:** add `-Oz` (or `-Os`) and consider `-flto`.
* **Memory:** `-sALLOW_MEMORY_GROWTH=1` lets the wasm heap grow at runtime; for fixed heaps set `-sINITIAL_MEMORY=‚Ä¶`. ([Emscripten][2])
* **ES modules:** `-sEXPORT_ES6=1 -sMODULARIZE=1` (shown above). ([Emscripten][3])
* **Exports (C):** either tag with `EMSCRIPTEN_KEEPALIVE` **or** list with `-sEXPORTED_FUNCTIONS=['_name']`. (C symbols are prefixed with `_`.) ([Emscripten][2])
* **C++ bindings:** add `--bind` and `#include <emscripten/bind.h>`, then declare with `EMSCRIPTEN_BINDINGS`. ([Emscripten][4])
* **Threads (optional):** Emscripten supports pthreads; for browsers you must serve with **COOP/COEP** headers to enable `SharedArrayBuffer`. See ‚ÄúPthreads support‚Äù and related guidance. ([Emscripten][6])
* **Multiple instances:** `MODULARIZE` allows creating multiple independent module instances if needed. ([Emscripten][3])

---

# 7) Nginx (static hosting + correct MIME)

Same idea as your Rust setup‚Äîjust serve the files:

```nginx
types { application/wasm wasm; }

server {
    listen 80;  server_name example.com;

    root /var/www/wasm-c-demo;
    index web/index.html;

    location / { try_files $uri $uri/ /web/index.html; }

    # cache wasm/js hard
    location ~* \.(wasm|js)$ {
        add_header Cache-Control "public, max-age=31536000, immutable";
        try_files $uri =404;
    }

    # Needed only if you enable threads (pthreads / SharedArrayBuffer):
    # add_header Cross-Origin-Opener-Policy same-origin;
    # add_header Cross-Origin-Embedder-Policy require-corp;
}
```

(Those COOP/COEP headers are only required for **threads**/**SharedArrayBuffer** usage.) ([Emscripten][6])

Deploy the built `pkg/` and `web/` directories to your doc root:

```
/var/www/wasm-c-demo/
‚îú‚îÄ pkg/
‚îî‚îÄ web/
```

---

# 8) Performance & footprint tips

* **Runtime cost:** Like with Rust/wasm-bindgen, there is **no TypeScript here** and nothing TS-related to ship.
* **Optimize:** Build with `-O3` (speed) or `-Oz` (size). Start with `-O3` for compute tasks.
* **Asset size:** Keep strings/buffers passing minimal; prefer numbers and pre-allocated buffers for hot loops.
* **Workers:** If heavy work blocks the UI, run your app logic in a **Web Worker** and postMessage results. Emscripten also offers **Wasm Workers API** and **pthreads** if you need true multithreading. ([Emscripten][7])

---

## What lands in `pkg/`?

With the commands above:

```
pkg/
‚îú‚îÄ c_demo.js        # ES module factory (import this)
‚îú‚îÄ c_demo.wasm
‚îú‚îÄ cpp_demo.js      # ES module factory (import this)
‚îî‚îÄ cpp_demo.wasm
```

No `.d.ts`, no `package.json`‚Äîjust the essentials.

---

### TL;DR

* Use **Emscripten** (`emcc`/`em++`) for C/C++ ‚Üí WASM.
* Build with **ESM** output: `-sEXPORT_ES6=1 -sMODULARIZE=1`.
* Export C with `EMSCRIPTEN_KEEPALIVE` (or `-sEXPORTED_FUNCTIONS`), call via `cwrap`.
* For C++ use **Embind** (`--bind`) for a clean JS API.
* Host statically with Nginx; add **COOP/COEP** only if you enable threads. ([Emscripten][1])


[1]: https://emscripten.org/docs/compiling/WebAssembly.html?utm_source=chatgpt.com "Building to WebAssembly"
[2]: https://emscripten.org/docs/tools_reference/settings_reference.html?utm_source=chatgpt.com "Emscripten Compiler Settings"
[3]: https://emscripten.org/docs/compiling/Modularized-Output.html?utm_source=chatgpt.com "Modularized Output"
[4]: https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html?utm_source=chatgpt.com "Embind ‚Äî Emscripten 4.0.19-git (dev) documentation"
[5]: https://emscripten.org/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html?utm_source=chatgpt.com "Interacting with code"
[6]: https://emscripten.org/docs/porting/pthreads.html?utm_source=chatgpt.com "Pthreads support"
[7]: https://emscripten.org/docs/api_reference/wasm_workers.html?utm_source=chatgpt.com "Wasm Workers API"
