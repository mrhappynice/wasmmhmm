## C/C++ Instrustions for min build

---

## 1. Project layout

On your host machine, create this structure:

```text
wasm-c-demo/
â”œâ”€ src/
â”‚  â”œâ”€ c_demo.c
â”‚  â””â”€ cpp_demo.cpp
â”œâ”€ web/
â”‚  â”œâ”€ index.html
â”‚  â””â”€ main.js
â”œâ”€ Dockerfile.build   # builder image (Emscripten)
â””â”€ Dockerfile         # runtime image (nginx)
```

All commands below assume youâ€™re in the `wasm-c-demo/` directory.

---

## 2. Source code

### `src/c_demo.c`

```c
#include <emscripten/emscripten.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>    // snprintf
#include <string.h>   // memset
#include <stdlib.h>   // malloc, free

EMSCRIPTEN_KEEPALIVE
const char* greet(const char* name) {
  // NOTE: returns static storage for simplicity; for real apps, pass a JS buffer in.
  static char buf[128];
  snprintf(buf, sizeof(buf), "hello, %s ðŸ‘‹ (from C/WASM)", name ? name : "world");
  return buf;
}

EMSCRIPTEN_KEEPALIVE
uint32_t count_primes(uint32_t n) {
  if (n < 2) return 0;

  uint32_t size = n + 1;
  uint32_t count = 0;

  bool *is_prime = (bool*)malloc(size * sizeof(bool));
  if (!is_prime) return 0;

  memset(is_prime, true, size * sizeof(bool));
  is_prime[0] = false;
  is_prime[1] = false;

  for (uint32_t p = 2; p * p <= n; ++p) {
    if (is_prime[p]) {
      for (uint32_t m = p * p; m <= n; m += p) {
        is_prime[m] = false;
      }
    }
  }

  for (uint32_t i = 2; i <= n; ++i) {
    if (is_prime[i]) ++count;
  }

  free(is_prime);
  return count;
}
```

---

### `src/cpp_demo.cpp`

```cpp
#include <string>
#include <vector>
#include <algorithm>
#include <cstdint>
#include <emscripten/bind.h>

std::string greet_cpp(std::string name) {
  return "hello, " + (name.empty() ? std::string("world") : name) + " ðŸ‘‹ (from C++/WASM)";
}

uint32_t count_primes_cpp(uint32_t n) {
  if (n < 2) return 0;

  std::vector<bool> is_prime(n + 1, true);
  is_prime[0] = false;
  is_prime[1] = false;

  for (uint32_t p = 2; p * p <= n; ++p) {
    if (is_prime[p]) {
      for (uint32_t m = p * p; m <= n; m += p) {
        is_prime[m] = false;
      }
    }
  }

  return std::count(is_prime.begin(), is_prime.end(), true);
}

EMSCRIPTEN_BINDINGS(my_module) {
  emscripten::function("greet_cpp", &greet_cpp);
  emscripten::function("count_primes_cpp", &count_primes_cpp);
}
```

---

## 3. Frontend

### `web/index.html`

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>C/C++ â†’ WebAssembly Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>body{font-family:system-ui,sans-serif;margin:2rem}</style>
</head>
<body>
  <h1>C/C++ â†’ WASM (no frameworks)</h1>

  <div>
    <input id="name" placeholder="Your name" />
    <button id="hello">Greet (C)</button>
    <button id="hello_cpp">Greet (C++)</button>
    <div id="greeting"></div>
  </div>

  <div style="margin-top:1rem">
    <input id="limit" type="number" value="100000" />
    <button id="count">Count primes â‰¤ n (C)</button>
    <button id="count_cpp">Count primes â‰¤ n (C++)</button>
    <div>Result: <span id="result">â€”</span></div>
  </div>

  <script type="module" src="./main.js"></script>
</body>
</html>
```

---

### `web/main.js`

```js
// Import ES-module factories generated by emscripten:
import createC from "../pkg/c_demo.js";
import createCpp from "../pkg/cpp_demo.js";

const C = await createC();     // loads c_demo.wasm
const CPP = await createCpp(); // loads cpp_demo.wasm

// Plain C exports via cwrap
const greet = C.cwrap("greet", "string", ["string"]);
const count_primes = C.cwrap("count_primes", "number", ["number"]);

// C++ Embind exports are methods on the module:
const greet_cpp = CPP.greet_cpp;
const count_primes_cpp = CPP.count_primes_cpp;

document.getElementById("hello").onclick = () => {
  const name = document.getElementById("name").value || "world";
  document.getElementById("greeting").textContent = greet(name);
};

document.getElementById("hello_cpp").onclick = () => {
  const name = document.getElementById("name").value || "world";
  document.getElementById("greeting").textContent = greet_cpp(name);
};

document.getElementById("count").onclick = () => {
  const n = +document.getElementById("limit").value || 0;
  const t0 = performance.now();
  const c = count_primes(n);
  const t1 = performance.now();
  document.getElementById("result").textContent =
    `${c} primes (C) in ${(t1 - t0).toFixed(1)} ms`;
};

document.getElementById("count_cpp").onclick = () => {
  const n = +document.getElementById("limit").value || 0;
  const t0 = performance.now();
  const c = count_primes_cpp(n);
  const t1 = performance.now();
  document.getElementById("result").textContent =
    `${c} primes (C++) in ${(t1 - t0).toFixed(1)} ms`;
};
```

---

## 4. Dockerfiles

### `Dockerfile.build` (builder: Emscripten â†’ WASM/JS)

```dockerfile
FROM debian:stable-slim

# Build dependencies
RUN apt-get update && apt-get install -y \
    git \
    build-essential \
    cmake \
    python3 \
    ca-certificates \
    bash \
 && rm -rf /var/lib/apt/lists/*

# Install Emscripten SDK
RUN git clone https://github.com/emscripten-core/emsdk /emsdk \
 && cd /emsdk \
 && ./emsdk install latest \
 && ./emsdk activate latest

# Use bash so we can `source` emsdk_env.sh
SHELL ["/bin/bash", "-lc"]

WORKDIR /app

# Copy project sources
COPY src ./src
COPY web ./web

# Build C and C++ â†’ WASM + JS into ./pkg
RUN mkdir -p pkg \
 && source /emsdk/emsdk_env.sh \
 && emcc src/c_demo.c -O3 \
      -sENVIRONMENT=web \
      -sEXPORT_ES6=1 -sMODULARIZE=1 \
      -sALLOW_MEMORY_GROWTH=1 \
      -sEXPORTED_RUNTIME_METHODS=['ccall','cwrap'] \
      -o pkg/c_demo.js \
 && em++ src/cpp_demo.cpp -O3 \
      -sENVIRONMENT=web \
      -sEXPORT_ES6=1 -sMODULARIZE=1 \
      -sALLOW_MEMORY_GROWTH=1 \
      --bind \
      -o pkg/cpp_demo.js

CMD ["bash"]
```

---

### `Dockerfile` (runtime: nginx static server)

Image name: **`wasm-proj`**
Container name: **`wasm-proj-cont`**

```dockerfile
FROM debian:stable-slim

RUN apt-get update && apt-get install -y nginx \
 && rm -rf /var/lib/apt/lists/*

# Remove default site to avoid duplicate default_server conflicts
RUN rm -f /etc/nginx/sites-enabled/default

# Web root
RUN mkdir -p /var/www/wasm-c-demo

# Copy frontend and built assets
COPY web/ /var/www/wasm-c-demo/
COPY pkg/ /var/www/wasm-c-demo/pkg/

# Single server block
RUN printf 'server {\n\
    listen 80;\n\
    server_name _;\n\
    root /var/www/wasm-c-demo;\n\
    index index.html;\n\
\n\
    location / {\n\
        try_files $uri $uri/ /index.html;\n\
    }\n\
\n\
    location ~* \\.(wasm|js)$ {\n\
        add_header Cache-Control "public, max-age=31536000, immutable";\n\
        try_files $uri =404;\n\
    }\n\
}\n' > /etc/nginx/conf.d/wasm_site.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

---

## 5. Build & run instructions

From the project root (`wasm-c-demo/`):

### 5.1 Build the builder image and generate `pkg/`

```bash
# Build the builder image
docker build -f Dockerfile.build -t wasm-proj-build .

# Create a container from the builder image
docker create --name wasm-proj-build-cont wasm-proj-build

# Copy the generated pkg/ directory from the container to the host
docker cp wasm-proj-build-cont:/app/pkg ./pkg

# Remove the temporary container
docker rm wasm-proj-build-cont
```

After this, your host tree includes a `pkg/` like:

```text
pkg/
â”œâ”€ c_demo.js
â”œâ”€ c_demo.wasm
â”œâ”€ cpp_demo.js
â””â”€ cpp_demo.wasm
```

---

### 5.2 Build the runtime image

```bash
docker build -t wasm-proj .
```

---

### 5.3 Run the server container

```bash
docker run --rm --name wasm-proj-cont -p 8080:80 wasm-proj
```

Then open in your browser:

```text
http://localhost:8080/
```

You should see:

* Buttons responding to clicks
* Network tab loading:

  * `/main.js`
  * `/pkg/c_demo.js` + `/pkg/c_demo.wasm`
  * `/pkg/cpp_demo.js` + `/pkg/cpp_demo.wasm`

And youâ€™re done ðŸŽ‰
